= ReadMe Compose Forms
:icons: font
:stem:
:toc: left
:url-docs: https://asciidoctor.org/docs
:url-gem: https://rubygems.org/gems/asciidoctor

Compose Forms ist eine Library, mit welcher sich schnell und einfach schöne & benutzerfreundliche Formulare erstellen lassen.



image::desktop-form.png[width = 500]

Der Code zu diesem Beispiel ist hier zu finden:

_[silver]#demo > src > main > kotlin > demo > personForm#_

Eine zusätzliche Benutzer-unterstützende Feature ist die Möglichkeit, das Smartphone für die Eingabe der einzelnen Input-Felder verwenden zu können. Über einen Boolean kann entschieden werden, ob die Smartphone-Eingabe-Möglichkeit für das Formular freigegeben werden soll. Dem End-User ist es frei überlassen, ob er das Smartphone verwenden möchte oder nicht. Über einen Button im Formular kann das Smartphone via QR-Code mit dem Desktop-Formular verbunden werden. Auf dem Smartphone werden dann individuelle Eingabe-Masken zum auf dem Desktop-fokussierten Inputfeld angezeigt.

image::smartphone-calc.png[width = 250]

*Hinweis:*
Die Library befindet sich gerade im Entwicklungszustand und wird laufend verbessert, daher sind noch nicht alle Funktionalitäten verfügbar.

== Übersicht
Für die Erstellung eines Formulares sind grundsätzlich folgende 3 Klassen nötig:

* Model, in welchem Attribute und Gruppen definiert werden
* Enum, in welchem die Label-Namen definiert werden
* Starter-Klasse

== Model

Um ein Formular zu erstellen, muss zuerst ein Model erstellt werden. Dieses sollte das BaseModel implementieren. +

[source,kotlin]
class UserDefinedModel : BaseModel(){ }

Nun kann in einem init-Block, welcher beim starten 1x ausgeführt wird, der Applikationstitel festgelegt werden, die Sprache gesetzt werden und falls das Smartphone verwendet werden soll auch dieses startbar gemacht werden.

[source,kotlin]
init {
        setTitle("Demo Title")
        setCurrentLanguageForAll("english")
        startUp()
}

Jetzt können hier im Model alle benötigten Attribute definiert werden.





== Attribute

=== Übersicht
Ein Attribut ist eine Wiederspiegelung eines Objektes eines bestimmten Typs
mit allen Werten und Informationen, die zur Interaktion (z.B. zum Speichern etc.) benötigt werden.

In dieser API gibt es folgende Attribut-Typen:

image::attribute-types.png[]

[red]#Orange:# Abstrakte Klassen  +
[blue]#Blau:# Konkrete Implementierungen. Diese können verwendet werden.




=== So wird ein Attribut erstellt:

Ein Beispiel: +
Es wird ein StringAttribut erstellt, in welchem der Strassenname gespeichert werden soll.

[source,kotlin]
val street = StringAttribute(model = this, label = PersonLabels.STREET)

Ein Attribut hat verschiedene Parameter, welche der Konfiguration des Attributs dienen. Bestimmte Parameter müssen angegeben werden (im Folgenden mit * markiert), andere sind optional und haben bereits einen Default-Wert gesetzt.


.Attribut-Parameter
[cols="1,1,2",width=100%,frame=topbot]
|===
| Property | Typ |Beschreibung

|<<anchor-model, model *>>
|IModel
|Model, welches alle Attribute verwaltet

| <<anchor-label, label *>>
| L
| Label-Text

| <<anchor-value, value>>
| T?
| letzter valider Wert

| <<anchor-required, required>>
| Boolean
| Ist das Attribut ein Pflichtfeld?

| <<anchor-readOnly, readOnly>>
| Boolean
| Ist das Attribut ein schreibgeschütztes Feld, das nicht verändert werden kann?

| <<anchor-onChangeListeners, onChangeListeners>>
| List<(T?) -> Unit>
| Listener, die auf Wert-Änderungen reagieren

| <<anchor-validators, validators>>
| List<SemanticValidator<T>>,
| Validatoren, die die festlegen wann der user input valid, invalid & onRightTrack ist

| <<anchor-convertibles, convertibles>>
| List<CustomConvertible>
| Convertibles, die dem User eine einfachere Eingabe erlauben

| <<anchor-meaning, meaning>>
| SemanticMeaning<T>
| Dem value eine semantische Bedeutung geben (beispielsweise, dass es eine Währung ist)

|===

Bestimmte Attribute besitzen weitere Parameter:

.Weitere Attribut-Parameter
[cols="1,1,1,1",width=100%,frame=topbot]
|===
| Attribut(e) | Property | Typ |Beschreibung

| FloatingPointAttribute
| <<anchor-decimalPlaces, decimalPlaces>>
| Int
| Legt die Anzahl zugelassener Nachkommastellen fest.

| SelectionAttribute
| <<anchor-possibleSelections, possibleSelections *>>
| Set<String>
| Legt das Set an Auswahlmöglichkeiten fest.

|===




== Gruppen

Nachdem alle Attribute erstellt wurden, können diese nun Gruppen zugeordnet werden. Nur Attribute, welche mind. einer Gruppe zugewiesen sind werden im Formular angezeigt.

Beispiel: Erstellung einer Gruppe im Model:

[source, kotlin]
val group1 = Group(this, "Group-Name",
Field(s, FieldSize.SMALL),
Field(d1, FieldSize.SMALL),
Field(d2),
Field(selectionValue))

Eine Gruppe besitzt folgende Parameter:

.Group-Parameter
[cols="1,1,2",width=100%,frame=topbot]
|===
| Property | Typ |Beschreibung

|<<anchor-group-model, model *>>
|IModel
|Model, welches alle Attribute und Gruppen verwaltet.

| <<anchor-group-title, title *>>
| String
| Gruppen-Titel

| <<anchor-fields, field>>
| vararg
| Alle Felder die angezeigt werden sollen.

|===

Die Attribute können hier bewusst in gewünschter Reihenfolge in den Gruppen platziert werden. Auch die Grösse der Felder kann bestimmt werden (SMALL oder NORMAL).

== Starterklasse erstellen

Das Model ist nun fertig. Nun fehlt nur noch die Starterklasse, in welcher das UI mit dem model verbunden wird, um die Applikation zu starten.

Es wird eine neue Kotlin-Klasse erstellt, in folgendem Beispiel _Main.kt_.

[source, kotlin]
@ExperimentalFoundationApi
fun main() = Window() {
        val model = remember { UserDefinedModel() }
        Form().of(model)
}

Wichtig sind die Annotation _@ExperimentalFoundationApi_ und das _remember_ beim Initialisieren des Models

Beim Window bieten sich folgende Parameter an, um das Window optimal anzuzeigen:

.Hilfreiche Window-Parameter (von Compose for Desktop)
[cols="1,1,2",width=100%,frame=topbot]
|===
| Property | Typ |Beschreibung

| title
| String
| Titel des Fensters definieren

| size
| IntSize
| Die Grösse des Fensters beim Aufstarten definieren.

|===


== UI modifizieren (optional)

=== Farben ändern

Die Formular-Farben können im File _FormColors.kt_ ganz einfach modifiziert werden, in dem die Farbwerte in den Enums angepasst werden.

Das File befindet sich hier:

_[silver]#common > src > main > kotlin > ui > theme > FormColors.kt#_

== User-Experience


=== Zur Verfügung stehende Aktionen

image::header-functions.png[width =  600]


.User-Aktionen
[cols="3,1,3",width=100%,frame=topbot]
|===
| Funktionalität | aufgerufene Model-Funktion | Auswirkung

a|
image::language.png[width = 150]
| setCurrentLanguageForAll( lang : String)
| Setzt die aktuelle Sprache. Die Sprachen müssen zuvor im Label-Enum definiert werden. (siehe <<anchor-label, label>>) +
_Diese Funktionalität ist noch nicht vollständig implementiert._


a|image::reset.png[width = 90]
| resetAll()
| Setzt die Werte aller Attribute auf die zuletzt gespeicherten Werte zurück.


a|image::save.png[width = 84]
| saveAll()
| Speichert die Werte (User-Inputs) aller Attribute, sofern alle in einem validen Zustand sind.


a|
image::qrCode.png[width = 150]
image::qr-code.png[]
|
| Generiert einen QR-Code, sodass sich der User mit dem Smartphone verbinden kann.

|===

=== 3 Stati

Für eine bessere User-Experience können sich die Attribute in 3 verschiedenen Stati befinden. +
Mit dem _rightTrack_-Status sind die Zeiten vorbei, in denen sich der User über rote Fehlermeldungen aufregt, die von Anfang an angezeit werden, bevor der User auch nur die Chance hatte sich um einen richtigen Input zu bemühen. Der rightTrack-Status gibt an, ob sich der User auf dem richtigen Weg zu einem validen Input befindet. Erst, wenn der Input wirklich in die falsche Richtung geht wird der Input als invalid angezeigt.

.Übersicht zu den 3 Stati
[cols="2,1,3",width=100%,frame=topbot]
|===
| Aussehen | Status | Beschreibung

a|image::valid.png[width = 200]
| *valid* +

_(gültig)_
| Der Input ist in einem validen Zustand und kann somit gespeichert werden.
Valid  bedeutet der eingegebene Input (String): +
- kann in den Typ des Attributs umgewandelt werden +
- ist bezüglich des Parameter <<anchor-required, required>> in einem gültigen Zustand +
- ist bezüglich aller gesetzten Validatoren in einem gültigen Zustand +


a|image::invalid.png[width = 200]
| *invalid* +

_(nicht gültig)_
| Der Input befindet sich in einem invaliden Zustand und kann nicht abgespeichert werden.
Wenn der Input (String) nicht valid ist ist er in einem invaliden Zustand.


a|image::rigthtTrack.png[width = 200]
| *rightTrack* +

_(auf dem richtigen Weg zu einem validen Zustand)_
| Der rightTrack-Zustand besteht zusätzlich zu den beiden obigen. (Wenn der rightTrack-Zustand gesetzt ist, ist der Input also gleichzeitig in einem rightTrack-Zustand und einem invaliden oder validen Zustand. Wenn er nicht gesetzt ist, ist der Input invalid)

Der Input wird dem User als rightTrack-Zustand angezeigt, wenn sich der Input in einem Zustand befindet, der sich auf dem richtigen Weg zu einem validen Zustand befindet. Sobald der Zustand valid ist wird das Attribut als valid angezeigt. +
Der rightTrack Zustand wird nur angezeigt, wenn das Attribut noch nicht fokussiert wurde oder gerade fokussiert ist, danach wechselt es wieder in einen invaliden Zustand.


|===

==== Beispiel
Die obigen Inputfelder gehören zu folgendem Beispiel:

image::example-stati.png[width = 800]

Der Input muss zwischen 3 und 10 Zeichen enthalten, um valid zu sein.



.Verhalten der Input-Felder
[cols="1,2,2",width=100%,frame=topbot]
|===
|Anz. Characters +
(Input-Länge)| Aussehen fokussiertes Feld| Aussehen nicht fokussiertes Feld +
(nachdem es bereits fokussiert wurde)

|0 - 2
a|image::rigthtTrack.png[width = 200]

rightTrack
a|image::rightTrack-unfocused.png[width = 200]
invalid

| 3 - 10
a|image::valid.png[width = 200]
valid
a|
image::valid-unfocused.png[width = 200]
valid

| 10 - ...
a|image::invalid.png[width = 200]
invalid
a|
image::invalid-unfocused.png[width = 200]
invalid
|===


== Tiefergehende Information / Hilfestellung

=== Komplikationen beim Starten

Was tun, wenn sich die Applikation nicht starten lässt?

Checke, ob in den Configurations die Variable _-cp $Classpath$_ bei der Starterklasse unter VM options gesetzt ist.

image::edit-configurations.png[width = 300]

image::configuration-window.png[width = 800]

Starte dann die Applikation erneut.

=== Attribut-Parameter

Im Folgenden eine detaillierte Erklärung zur richtigen Erstellung der Attribut-Parameter

==== [[anchor-model]] model _(mandatory)_

Das Model der Gruppe, in welcher sich das Attribut befindet, muss dasselbe sein, wie das Model des Attributs. (Falls dies nicht der Fall ist wird eine Exception geworfen.)

*Beispiel 1 - Alles in einem Model* +
Die Attribute und Gruppen werden im selben Model erstellt.
Sowohl beim Attribut als auch bei der Gruppe wird _this_ als Model übergeben. +

( siehe: _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )

*Beispiel 2 - Attribute und Gruppen in mehreren Klassen verteilt* +
Zusätzlich zu den Attributen aus Beispiel 1, soll ein weiteres Attribut auf dem Formular erscheinen. Dieses wird in diesem Beispiel direkt in der Starterklasse definiert und einer eigenen Gruppe übergeben. Damit es auf demselben Formular erscheint muss dasselbe Model als Parameter übergeben werden.

image::example_parameter_model.png[]

Nun erscheint in dem Formular die zusätzliche Gruppe mit dem Attribut unter den bereits im PersonModel definierten:

image::example_result_parameter_model.png[]

==== [[anchor-label]] label _(mandatory)_

Um Mehrsprachigkeit zu gewährleisten müssen die Labeltexte in einem Enum angegeben werden.
Das Enum muss das Interface _ILabel_ implementieren und alle gewünschten Sprachen als Parameter mit Typ String definieren. +
Im Enum können nun Code-Variablen festgelegt werden, in welchen die Übersetzungen der Labeltexte definiert werden.

image::label-code.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonLabels#_ )

Bei den Attributen muss dann nur noch die richtige Code-Variable als Label angegeben werden.

image::label_in_model.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )


==== [[anchor-value]] value _(optional)_
Wenn ein Attribut beim ersten Öffnen des Formulars nicht leer sein soll, kann über den Parameter _value_ der Wert gesetzt werden. +


image::value-example.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )

Der Wert muss vom gleichen Typ sein wie das Attribut! Bei keiner Angabe wird der Default-Wert _null_ gesetzt.



==== [[anchor-required]] required _(optional)_

Wenn ein Atribut ein Pflichtfeld sein soll (also der User also gezwungen werden soll eine Eingabe zu tätigen und das Feld nicht leer zu lassen), kann beim Parameter required _true_ übergeben werden.

image::required-example.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )


Bei keiner Angabe wird der Default-Wert _false_ gesetzt.



==== [[anchor-readOnly]] readOnly _(optional)_

Wenn ein Attribut für den User nur lesbar aber nicht modifizierbar sein soll, kann beim Parameter readonly _true_ übergeben werden.

image::value-example.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )

Bei keiner Angabe wird der Default-Wert _false_ gesetzt.



==== [[anchor-onChangeListeners]] onChangeListeners _(optional)_

Mit onChangeListenern kann man bei Wertänderungen anderer Attribute das Attribut, auf dem die ChangeListener als Parameter übergeben sind, ändern.
Da mehrere onChangeListener übergeben werden können, muss immer eine Liste übergeben werden. In dieser können dann die onChangeListener gesetzt werden.

*Einen onChangeListener definieren:*

[fuchsia]#Attribut, dessen Wert observiert werden soll# *addOnChangeListener {* +
[red]#Lambda-Parameter für dieses Attribut# *,* [purple]#Lambda-Parameter für zu observierenden Wert# *->* _Was wann passieren soll_ *}*

*Beispiel:*

image::onChangeListener.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )

Sobald beim Attribut Beruf (occupation) etwas eingegeben wurde (Wert != null), soll die Steuernummer (taxnumber) zu einem Pflichtfeld werden.

Bei keiner Angabe wird der Default-Wert _emptyList()_ gesetzt.

==== [[anchor-validators]] validators _(optional)_



===== Number-Validator

.Number-Validator-Properties
[cols="1,1,2",width=100%,frame=topbot]
|===
| Property | Typ |Beschreibung

| lowerBound
| Int
| untere Grenze für Input

| upperBound
| Int
| obere Grenze für Input

| stepSize
| Int
| Schrittgrösse

| stepStart
| Int
| Zahl, von der aus die Schritte nach oben/unten gerechnet werden
|===

==== [[anchor-convertibles]] convertibles  _(optional)_
==== [[anchor-meaning]] meaning  _(optional)_
==== [[anchor-decimalPlaces]] decimalPlaces _(optional)_

*Nur für FloatingPoint-Attribute*

Bei Attributen die Kommazahlen als Wert speichern, kann zusätzlich angegeben werden wie viele Nachkommastellen maximal erwünscht sind.
Sobald der User mehr Kommastellen eingibt wird der Input invalid.

image::decimalPlaces.png[]
( _[silver]#demo > src > main > kotlin > demo > personForm > PersonModel#_ )

Bei keiner Angabe wird der Default-Wert _8_ gesetzt.

==== [[anchor-possibleSelections]] possibleSelections _(mandatory)_
*Nur für Selection-Attribute*

Beim Selection-Attribut müssen die Auswahlmöglichkeiten, die dem User zur Verfügung stehen über den Parameter _possibleSelections_, angegeben werden. Die Auswahlmöglichkeiten müssen als Strings in einem Set übergeben werden.

image::possibleSelections.png[]

_Momentan ist hier noch keine Mehrsprachigkeit-Möglichkeit verfügbar. Dies wird sich in Zukunft ändern._

=== Group-Parameter

Im Folgenden eine detaillierte Erklärung zur richtigen Erstellung der Group-Parameter

==== [[anchor-group-model]] model _(mandatory)_


==== [[anchor-group-title]] title _(mandatory)_


==== [[anchor-fields]] fields _(optional)_



== Konfiguration zur Laufzeit

Diese Funktionen sind beispielsweise bei Verwendung von onChange-Listenern hilfreich.

=== Attribut-Funktionen

Die folgenden Funktionen können auf Attributen aufgerufen werden:

.Einige hilfreiche Setter-Funktionen eines Attributs
[cols="2,2",width=100%,frame=topbot]
|===
| Funktion |  Beschreibung

| setValAsText(valueAsText : String)
| Den User-Input setzen +

| setRequired(isRequired : Boolean)
| Siehe Attribut-Parameter <<anchor-required, required>>

| setReadOnly(isReadOnly : Boolean)
| Siehe Attribut-Parameter <<anchor-readOnly, readOnly>>

|===


.Einige hilfreiche Getter-Funktionen eines Attributs
[cols="2,1,2",width=100%,frame=topbot]
|===
| Funktion | Rückgabe-Typ | Beschreibung

| getId()
| Int
| Gibt die Id des Attributs zurück

| getValue()
| T?
| Gibt den letzten validen Wert zurück.

| getSavedValue()
| T?
| Gibt den gespeicherten Wert zurück.

| getRightTrackValue()
| T?
| Gibt den letzten right-Track-validen Wert zurück.

| getValueAsText()
| String
| Gibt den aktuellen User-Input-String zurück

| getPossibleSelections()
| Set<String>
| Beim Selection-Attribut wird das Set mit den gesetzten Auswahlmöglichkeiten zurückgegeben. Bei anderen Attributtypen bestehen die Auswahlmöglichkeiten des Sets aus früheren User-Input-Eingaben (noch nicht implementiert).

| getLabel()
| String
| Gibt den aktuellen Label-Text zurück

| isRequired()
| Boolean
| Gibt zurück, ob eine Eingabe erforderlich ist

| isReadOnly()
| Boolean
| Gibt zurück, ob der Wert verändert werden darf

| isChanged()
| Boolean
| Gibt zurück, ob value gleich ist wie savedValue

| isValid()
| Boolean
| Gibt zurück, ob der User-Input (valueAsText) valid ist

| isRightTrackValid()
| Boolean
| Gibt zurück, ob der User-Input auf dem richtigen Weg zu einem validen Input ist.

| getErrorMessages()
| List<String>
| Gibt alle auf den aktuellen Input (valueAsText) zutreffenden ErrorMessages zurück

|===

=== Model-Funktionen

Die folgenden Funktionen können auf einem Model aufgerufen werden:

.Einige hilfreiche Funktionen des Base-Models (Diese Funktionen beeinflussen alle Attribute)
[cols="2,2",width=100%,frame=topbot]
|===
| Funktion |  Beschreibung

| setValAsText(valueAsText : String)
| Den User-Input setzen +

| setRequired(isRequired : Boolean)
| Siehe Attribut-Parameter <<anchor-required, required>>

| setReadOnly(isReadOnly : Boolean)
| Siehe Attribut-Parameter <<anchor-readOnly, readOnly>>

|===